#!/usr/bin/python

import sys
import os
import argparse
import re

#reserved field names
NAME_MARKER         = '$name'
FIELDS_MARKER       = '$fields'
METHOD_MARKER       = '$methods'
TYPE_MARKER         = '$type'
PARAMETERS_MARKER   = '$params'
ENUM_MARKER         = '$is_enum'

#general indices
NAME_ID = 1
TYPE_ID = 0

#keywords
__TABLE = 'table'
__METHOD = 'metamethod'
__ENUM = 'enumeration'

#common script  generated file header
__HEADER = "// This file is generated by python script.\n// Do not perform any manual modifications."

# Functions

def checkTemplates(file, lineNumber, line):
    if re.search('(\w+)\s*<(.+)>', line):
        raise Exception('template detected in file %s @ ln%d: %s' % (file.name, lineNumber, line))

#############################################
#  HEADER FILE GENERATOR
#############################################

#all functions are templates. This required to push and parse complex template objects like std::vectors, etc.
def writeHeaderPreDefinitions(file):
    file.write(
"""#include <lua.hpp>

///////////////// PRE DEFINED FUNCTIONS /////////////////
// error trigger
inline void riseError(lua_State* L, const std::string& message)
{
    lua_pushstring(L, message.c_str());
    lua_error(L);
}

template <class T>
void parse<T>(lua_State* L, T& value, int index)
{
    riseError(L, "unknown type provided for parsing"); 
}


template <class T>
void push<T>(lua_State* L, T& value)
{
    riseError(L, "unknown type provided for push"); 
}

///////////////////////////////////////////////////////////////////
// DEFAULT PARSERS
///////////////////////////////////////////////////////////////////
template<>
void parse<int>(lua_State* L, int& value, int index)
{
    value = lua_tointeger(L, index);
}

template<>
void parse<bool>(lua_State* L, bool& value, int index)
{
    value = lua_tointeger(L, index);
}

template<>
void parse<double>(lua_State* L, double& value, int index)
{
    value = lua_tonumber(L, index);
}

template<>
void parse<float>(lua_State* L, float& value, int index)
{
    value = lua_tonumber(L, index);
}


template<>
void parse<std::string>(lua_State* L, std::string& value, int index)
{
    value = lua_tostring(L, index);
}

///////////////////////////////////////////////////////////////////
// DEFAULT PUSH FUNCTIONS
///////////////////////////////////////////////////////////////////
template <>
void push<int>(lua_State* L, int& value)
{
    lua_pushinteger(L, value);
}

template <>
void push<bool>(lua_State* L, bool& value)
{
    int result = 0;
    lua_pushinteger(L, result);
    value = !!result;
}

template <>
void push<double>(lua_State* L, double& value)
{
    lua_pushnumber(L, value);
}

template <>
void push<float>(lua_State* L, float& value)
{
    lua_pushnumber(L, value);
}

template <>
void push<std::string>(lua_State* L, std::string& value)
{
    lua_pushstring(L, value.c_str());
}

///////////////// GENERATED FUNCTIONS /////////////////
""")

def generateHeaderFile(tableList, header):
    header.write("%s\n\n" % __HEADER)

    writeHeaderPreDefinitions(header)
#
#    for table in tableList:
#        declDictionary = {'$name' : table[NAME_MARKER], '$type' : 'table', '$registrator' : ''}
#        if table[ENUM_MARKER]:
#            declDictionary.update({'$type' : 'value'})
#            declDictionary.update({'$registrator' : 'int register_%($name)s(lua_State* L);\n' % table})
#
#        header.write(
#"""
#// Accessors for %($name)s enumeration
#%($registrator)svoid parse_%($name)s(lua_State* L, %($name)s& %($type)s, int index = -1);
#int push_%($name)s(lua_State* L, const %($name)s& %($type)s);
#""" % declDictionary)
        

#############################################
#  SOURCE FILE GENERATOR
#############################################

# push function
def generateEnumParser(table, sourceFile):
    sourceFile.write("""
template<>
void parse<%($name)s>(lua_State* L, %($name)s& value, int index)
{
    if (!lua_isinteger(L, index))
        riseError(L, "invalid type for parameter of type %($name)s");

    int intermediateValue = 0;
    parse(L, intermediateValue, index);
    value = intermediateValue;
} // end of parser %($name)s

""" % table)

# push function
def generateEnumPush(table, sourceFile):
    sourceFile.write("""
template<>
int push<%($name)s>(lua_State* L, const %($name)s& value)
{
    push(L, (int)value);
}

""" % table)

# register function
def generateEnumRegistrator(table, sourceFile):
    sourceFile.write("""
void register_%($name)s(lua_State* L)
{
    lua_getglobal(L, "%($name)s");
    if (!lua_isnil(L, -1))
        riseError(L, "enumerator %($name)s already registered");
""" % table)

    for record in table[FIELDS_MARKER]:
        sourceFile.write("""
    push(L, (int)%s::%s);
    lua_setfield(m_lua, -2, "%s")
""" % (table[NAME_MARKER], record[NAME_ID], record[NAME_ID]))

    sourceFile.write("""
    lua_setglobal(L, "%($name)s");
} // end of register %($name)s

""" % table)
#############################################
# parser
def generateParser(table, sourceFile):
    sourceFile.write("""
template<>
void parse<%($name)s>(lua_State* L, %($name)s& table, int index)
{
    luaL_checktype(L, -1, LUA_TTABLE);
    lua_pushnil(L);
    while(lua_next(L, -2))
    {
        std::string field(lua_tostring(L, -2));""" % table)

    for record in table[FIELDS_MARKER]:
        sourceFile.write("""
        if (0 == field.compare(\"%s\"))
        {
            parse(L, table.%s, -1);
            lua_pop(L, 1);
            continue;
        }""" % (record[NAME_ID], record[NAME_ID]))

    sourceFile.write("""
        riseError(L, "unknown field \\"" + field + "\\" found");
        lua_pop(L, 1);
    } /* while */
} // end of parser %($name)s

""" % table)

# push function
def generatePush(table, sourceFile):
    sourceFile.write("""
template<>
int push<%($name)s>(lua_State* L, const %($name)s& table)
{
    lua_newtable(L);
""" % table)

    for record in table[FIELDS_MARKER]:
        sourceFile.write("""
    push(L, table.%s);
    lua_setfield(m_lua, -2, "%s")
""" % (record[NAME_ID], record[NAME_ID]))

    sourceFile.write("\n} // end of push %($name)s\n\n" % table)

#############################################
# functions
def generatePushInterface(table, header, source):
    for method in table[METHOD_MARKER]:
        source.write("\nint luaC_%($name)s(lua_State* L)" % method)
        source.write("""
{
    luaL_checktype(L, 1, LUA_TUSERDATA);
    %($name)s* pThis = (%($name)s*)lua_getluserdata(l, 1);
    if (!pThis)
        riseError(L, "incorrect method parameter");
""" % table)
        # get parameters from LUA stack
        retvalsCount = 0 if method[TYPE_MARKER] == 'void' else 1;
        source.write("\n    // parse function parameters from lua stack\n"); # end of function
        for index, parameter in enumerate(method[PARAMETERS_MARKER]):
            source.write("    %s param%s;\n    parse(L, param%s, %d)\n" % (parameter[TYPE_ID], parameter[NAME_ID], parameter[NAME_ID], index + 2))

        source.write("\n    // call native function\n"); # start of function
        source.write("    %($type)s retVal = pThis->%($name)s(" % method) if 0 != retvalsCount else source.write("    pThis->%($name)s(" % method)

        # push parameters as arguments of native function
        for index, parameter in enumerate(method[PARAMETERS_MARKER]):
            if index < len(method[PARAMETERS_MARKER])-1:
                source.write("%s, " % parameter[NAME_ID])
            else:
                source.write("%s" % parameter[NAME_ID])
        source.write(");\n\n"); # end of function
        # form return value if needed
        if retvalsCount != 0:
            source.write("    push(L, retVal);\n")

        source.write("    return %d;\n}\n" % retvalsCount)

# source file itself
def generateSourceFile(tableList, headerName, source):
    if source.name != headerName:
        source.write(
"""%s

#include "%s"
""" % (__HEADER, headerName))

    for table in tableList:
        if table[ENUM_MARKER]:
            generateEnumParser(table, source)
            generateEnumPush(table, source)
            generateEnumRegistrator(table, source)
        else:
            generateParser(table, source)
            generatePush(table, source)
            generatePushInterface(table, headerName, source)

#############################################
#  TABLE PARSER
#############################################
def main():
    parser = argparse.ArgumentParser(description = 'C++ to Lua converter v0.1')
    parser.add_argument('-fl',  '--file_list',  required = True, type = argparse.FileType('r'), help = 'list of files to be processed', nargs = '+')
    parser.add_argument('-ho',  '--header',     required = True, type = argparse.FileType('w'), help = 'output header file name')
    parser.add_argument('-so',  '--source',     required = True, type = argparse.FileType('w'), help = 'output source file name')
    scriptArgs = parser.parse_args()

    tableList = []

    methodPattern = re.compile("""%s\s+   # 'metamethod' marker is mandatory
        (\w+)\s+(\w+)\s*                  # function return type and name
        \(\s*
        (.*)                              # function parameters
        \s*\)
        \s*=\s*0\s*;                      # PURE marker is mandatory
        """ % __METHOD,
        re.VERBOSE)

    #TODO:
    # allow pointer registration in structure
    fieldPattern = re.compile('(\w+)\s+(\w+)\s*;')
    enumPatter = re.compile("""
        (\w+)                           # enumerated value name
        (?:\s*=\s*.*)?                  # enum assigment is optional, symbol group is not captured
        \,?                             # comma is optional
        """, 
        re.VERBOSE) # enumeration field with optional assignment

    currentTable = {}
    for file in scriptArgs.file_list:
        lineNumber = 0

        tableStarted = False
        enumeration = False
        for line in file:
            lineNumber += 1
            line = re.sub('\s+', ' ', line)       # replace complex spaces by simple one
            line = re.sub('\/\/.*', '', line)     # remove single line comments
            line = re.sub('std\:\:', '', line)    # remove std:: prefixes
            #TODO:
            # undertand how multiple subline comments can be removed.
            # understand multiline comments as well
            line = re.sub('\/\*.*\*\/', '', line) # remove single subline comment
            line = line.strip()

            if line is '':
                continue

            index = 0
            if not tableStarted:
                tableName = re.match('%s\s+(\w+)' % __TABLE, line) or re.match('%s\s+(\w+)' % __ENUM, line)
                if tableName is not None:
                    enumeration = (re.search(__ENUM, line) is not None)
                    currentTable = {NAME_MARKER : tableName.group(1), FIELDS_MARKER : [], METHOD_MARKER : [], ENUM_MARKER : enumeration}
                    tableStarted = True
                    line = line[tableName.span()[1]:].strip()
                else:
                    continue

            parameter = re.search("{",line)
            if parameter is not None:
                line = line[parameter.span()[1]:].strip()

            parameter = fieldPattern.match(line) if not enumeration else enumPatter.match(line)
            # field detected. parse it and save as a tuple (type, name)
            if parameter is not None and len(parameter.groups()) > 0:
                # check template in translated field. non translated fields may be templates
                if enumeration:
                    currentTable[FIELDS_MARKER].append( ('int', parameter.groups(0)[0]) )
                else:
                    checkTemplates(file, lineNumber, line)
                    currentTable[FIELDS_MARKER].append( parameter.groups(0) )
            else:
                # function detected
                # Save function as a name, typoe and list of parameters.
                parameter = methodPattern.match(line)
                if parameter is not None and len(parameter.groups()) > 1:
                    # check template in translated method. non translated methods may be templates
                    checkTemplates(file, lineNumber, line)
                    funcParams = []
                    #TODO:
                    # const parameters are not allowed yet
                    for param in parameter.groups(0)[2].split(','):
                        checkTemplates(file, lineNumber, param.strip())
                        param = re.sub('\s*const\s+', '', param)
                        funcParameter = param.strip().split(' ')
                        funcParams.append( tuple(funcParameter) )

                    currentTable[METHOD_MARKER].append(
                            {
                                TYPE_MARKER: parameter.groups(0)[TYPE_ID],
                                NAME_MARKER: parameter.groups(0)[NAME_ID],
                                PARAMETERS_MARKER: funcParams
                            }
                        )

            if re.search("}", line) is not None:
                tableList.append(currentTable)
                currentTable = {}
                tableStarted = False
                enumeration  = False

    generateHeaderFile(tableList, scriptArgs.header)
    generateSourceFile(tableList, scriptArgs.header.name, scriptArgs.header)


if __name__=="__main__":
    main()

