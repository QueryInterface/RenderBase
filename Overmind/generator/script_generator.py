#!/usr/bin/python

import sys
import os
import argparse
import re

#reserved field names
NAME_MARKER         = '__name'
FIELDS_MARKER       = '__fields'
METHOD_MARKER       = '__methods'
TYPE_MARKER         = '__type'
PARAMETERS_MARKER   = '__params'
ENUM_MARKER         = '__is_enum'

#general indices
NAME_ID = 1
TYPE_ID = 0

#keywords
__TABLE = 'table'
__METHOD = 'metamethod'
__ENUM = 'enumeration'

#common script  generated file header
__HEADER = "// This file is generated by python script.\n// Do not perform any manual modifications."

# Functions

def checkTemplates(file, lineNumber, line):
    if re.search('(\w+)\s*<(.+)>', line):
        raise Exception('template detected in file %s @ ln%d: %s' % (file.name, lineNumber, line))

#############################################
#  HEADER FILE GENERATOR
#############################################

#all functions are templates. This required to push and parse complex template objects like std::vectors, etc.
def writeHeaderPreDefinitions(file):
    file.write(
"""#include <lua.hpp>

///////////////// PRE DEFINED FUNCTIONS /////////////////
// error trigger
inline void riseError(lua_State* L, const std::string& message)
{
    lua_pushstring(L, message.c_str());
    lua_error(L);
}

template <class T>
void parse<T>(lua_State* L, T& value, int index)
{
    riseError(L, "unknown type provided for parsing"); 
}


template <class T>
void push<T>(lua_State* L, T& value)
{
    riseError(L, "unknown type provided for push"); 
}

///////////////////////////////////////////////////////////////////
// DEFAULT PARSERS
///////////////////////////////////////////////////////////////////
template<>
void parse<int>(lua_State* L, int& value, int index)
{
    value = lua_tointeger(L, index);
}

template<>
void parse<bool>(lua_State* L, bool& value, int index)
{
    value = lua_tointeger(L, index);
}

template<>
void parse<double>(lua_State* L, double& value, int index)
{
    value = lua_tonumber(L, index);
}

template<>
void parse<float>(lua_State* L, float& value, int index)
{
    value = lua_tonumber(L, index);
}


template<>
void parse<std::string>(lua_State* L, std::string& value, int index)
{
    value = lua_tostring(L, index);
}

///////////////////////////////////////////////////////////////////
// DEFAULT PUSH FUNCTIONS
///////////////////////////////////////////////////////////////////
template <>
void push<int>(lua_State* L, int& value)
{
    lua_pushinteger(L, value);
}

template <>
void push<bool>(lua_State* L, bool& value)
{
    int result = 0;
    lua_pushinteger(L, result);
    value = !!result;
}

template <>
void push<double>(lua_State* L, double& value)
{
    lua_pushnumber(L, value);
}

template <>
void push<float>(lua_State* L, float& value)
{
    lua_pushnumber(L, value);
}

template <>
void push<std::string>(lua_State* L, std::string& value)
{
    lua_pushstring(L, value.c_str());
}

///////////////// GENERATED FUNCTIONS /////////////////
""")

def generateHeaderFile(tableList, header):
    header.write("%s\n\n" % __HEADER)

    writeHeaderPreDefinitions(header)
#
#    for table in tableList:
#        declDictionary = {'__name' : table[NAME_MARKER], '__type' : 'table', '__registrator' : ''}
#        if table[ENUM_MARKER]:
#            declDictionary.update({'__type' : 'value'})
#            declDictionary.update({'__registrator' : 'int register_%(__name)s(lua_State* L);\n' % table})
#
#        header.write(
#"""
#// Accessors for %(__name)s enumeration
#%(__registrator)svoid parse_%(__name)s(lua_State* L, %(__name)s& %(__type)s, int index = -1);
#int push_%(__name)s(lua_State* L, const %(__name)s& %(__type)s);
#""" % declDictionary)
        

#############################################
#  SOURCE FILE GENERATOR
#############################################

# push function
def generateEnumParser(table, header, source):
    header.write("""
template<>
void parse<%(__name)s>(lua_State* L, %(__name)s& value, int index)
{
    if (!lua_isinteger(L, index))
        riseError(L, "invalid type for parameter of type %(__name)s");

    int intermediateValue = 0;
    parse(L, intermediateValue, index);
    value = intermediateValue;
} // end of parser %(__name)s

""" % table)

# push function
def generateEnumPush(table, header, source):
    header.write("""
template<>
int push<%(__name)s>(lua_State* L, const %(__name)s& value)
{
    push(L, (int)value);
}

""" % table)

# register function
def generateEnumRegistrator(table, header, source):
    header.write("void register_%(__name)s(lua_State* L);\n" % table)

    source.write("""
void register_%(__name)s(lua_State* L)
{
    lua_getglobal(L, "%(__name)s");
    if (!lua_isnil(L, -1))
        riseError(L, "enumerator %(__name)s already registered");
""" % table)

    for record in table[FIELDS_MARKER]:
        source.write("    push(L, (int)%(__name)s" % table)
        source.write('::%(__name)s);\n    lua_setfield(m_lua, -2, "%(__name)s")\n\n' % record)

    source.write('    lua_setglobal(L, "%(__name)s");\n} // end of register %(__name)s\n\n' % table)
#############################################
# parser
def generateParser(table, header, source):
    header.write("""
template<>
void parse<%(__name)s>(lua_State* L, %(__name)s& table, int index)
{
    luaL_checktype(L, -1, LUA_TTABLE);
    lua_pushnil(L);
    while(lua_next(L, -2))
    {
        std::string field(lua_tostring(L, -2));""" % table)

    for record in table[FIELDS_MARKER]:
        header.write("""
        if (0 == field.compare(\"%(__name)s\"))
        {
            parse(L, table.%(__name)s, -1);
            lua_pop(L, 1);
            continue;
        }""" % record)

    header.write("""
        riseError(L, "unknown field \\"" + field + "\\" found");
        lua_pop(L, 1);
    } /* while */
} // end of parser %(__name)s

""" % table)

# push function
def generatePush(table, header, source):
    header.write("""
template<>
int push<%(__name)s>(lua_State* L, const %(__name)s& table)
{
    lua_newtable(L);
""" % table)

    for record in table[FIELDS_MARKER]:
        header.write("""
    push(L, table.%(__name)s);
    lua_setfield(m_lua, -2, "%(__name)s")
""" % record)

    header.write("\n} // end of push %(__name)s\n\n" % table)

#############################################
# functions
def generateInterface(table, header, source):
    for method in table[METHOD_MARKER]:
        source.write("\nint luaC_%(__name)s(lua_State* L)" % method)
        source.write("""
{
    luaL_checktype(L, 1, LUA_TUSERDATA);
    %(__name)s* pThis = (%(__name)s*)lua_getlightuserdata(L, 1);
    if (!pThis)
        riseError(L, "incorrect method parameter");
""" % table)
        # get parameters from LUA stack
        retvalsCount = 0 if method[TYPE_MARKER] == 'void' else 1;
        source.write("\n    // parse function parameters from lua stack\n"); # end of function
        for index, parameter in enumerate(method[PARAMETERS_MARKER]):
            source.write("    %(__type)s param%(__name)s;\n    parse(L, param%(__name)s, " % parameter)
            source.write("%d)\n" % (index + 2))

        source.write("\n    // call native function\n"); # start of function
        source.write("    %(__type)s retVal = pThis->%(__name)s(" % method) if 0 != retvalsCount else source.write("    pThis->%(__name)s(" % method)

        # push parameters as arguments of native function
        for index, parameter in enumerate(method[PARAMETERS_MARKER]):
            if index < len(method[PARAMETERS_MARKER])-1:
                source.write("%(__name)s, " % parameter)
            else:
                source.write("%(__name)s" % parameter)
        source.write(");\n\n"); # end of function
        # form return value if needed
        if retvalsCount != 0:
            source.write("    push(L, retVal);\n")

        source.write("    return %d;\n}\n" % retvalsCount)

# source file itself
def generateSourceFile(tableList, header, source):
    if source.name != header:
        source.write(
"""%s

#include "%s"
""" % (__HEADER, header.name))

    for table in tableList:
        if table[ENUM_MARKER]:
            generateEnumParser(table, header, source)
            generateEnumPush(table, header, source)
            generateEnumRegistrator(table, header, source)
        else:
            generateParser(table, header, source)
            generatePush(table, header, source)
            generateInterface(table, header, source)

#############################################
#  TABLE PARSER
#############################################
def main():
    parser = argparse.ArgumentParser(description = 'C++ to Lua converter v0.1')
    parser.add_argument('-fl',  '--file_list',  required = True, type = argparse.FileType('r'), help = 'list of files to be processed', nargs = '+')
    parser.add_argument('-ho',  '--header',     required = True, type = argparse.FileType('w'), help = 'output header file name')
    parser.add_argument('-so',  '--source',     required = True, type = argparse.FileType('w'), help = 'output source file name')
    scriptArgs = parser.parse_args()

    tableList = []

    methodPattern = re.compile("""%(__METHOD)s\s+               # 'metamethod' marker is mandatory
        (?P<%(TYPE_MARKER)s>\w+)\s+(?P<%(NAME_MARKER)s>\w+)\s*  # function return type and name
        \(\s*
        (?P<%(PARAMETERS_MARKER)s>.*)                           # function parameters
        \s*\)
        \s*=\s*0\s*;                                        # PURE marker is mandatory
        """ % globals(),
        re.VERBOSE)

    #TODO:
    # allow pointer registration in structure
    fieldPattern = re.compile('(?P<%(TYPE_MARKER)s>\w+)\s+(?P<%(NAME_MARKER)s>\w+)\s*;' % globals())
    enumPatter = re.compile("""
        (?P<%(NAME_MARKER)s>\w+)                     # enumerated value name
        (?:\s*=\s*.*)?                  # enum assigment is optional, symbol group is not captured
        \,?                             # comma is optional
        """ % globals(), 
        re.VERBOSE) # enumeration field with optional assignment

    currentTable = {}
    for file in scriptArgs.file_list:
        lineNumber = 0

        tableStarted = False
        enumeration = False
        for line in file:
            lineNumber += 1
            line = re.sub('\s+', ' ', line)       # replace complex spaces by simple one
            line = re.sub('\/\/.*', '', line)     # remove single line comments
            line = re.sub('std\:\:', '', line)    # remove std:: prefixes
            #TODO:
            # undertand how multiple subline comments can be removed.
            # understand multiline comments as well
            line = re.sub('\/\*.*\*\/', '', line) # remove single subline comment
            line = line.strip()

            if line is '':
                continue

            index = 0
            if not tableStarted:
                tableName = re.match('%s\s+(?P<%s>\w+)' % (__TABLE, NAME_MARKER), line) or re.match('%s\s+(?P<%s>\w+)' % (__ENUM, NAME_MARKER), line)
                if tableName is not None:
                    enumeration = (re.search(__ENUM, line) is not None)
                    currentTable = {NAME_MARKER : tableName.groupdict()[NAME_MARKER], FIELDS_MARKER : [], METHOD_MARKER : [], ENUM_MARKER : enumeration}
                    tableStarted = True
                    line = line[tableName.span()[1]:].strip()
                else:
                    continue

            parameter = re.search("{",line)
            if parameter is not None:
                line = line[parameter.span()[1]:].strip()

            parameter = fieldPattern.match(line) if not enumeration else enumPatter.match(line)
            # field detected. parse it and save as a tuple (type, name)
            if parameter is not None and len(parameter.groups()) > 0:
                # check template in translated field. non translated fields may be templates
                if not parameter.groupdict().has_key(TYPE_MARKER):
                    currentTable[FIELDS_MARKER].append( {TYPE_MARKER: 'int', NAME_MARKER: parameter.groupdict()[NAME_MARKER] } )
                else:
                    checkTemplates(file, lineNumber, line)
                    currentTable[FIELDS_MARKER].append( parameter.groupdict() )
            else:
                # function detected
                # Save function as a name, typoe and list of parameters.
                parameter = methodPattern.match(line)
                if parameter is not None and len(parameter.groups()) > 1:
                    # check template in translated method. non translated methods may be templates
                    checkTemplates(file, lineNumber, line)
                    funcParams = []
                    #TODO:
                    # const parameters are not allowed yet
                    funcDesc = parameter.groupdict()
                    for param in funcDesc[PARAMETERS_MARKER].split(','):
                        checkTemplates(file, lineNumber, param.strip())
                        param = re.sub('\s*const\s+', '', param)
                        param = re.sub('\&', '', param)
                        funcParameter = param.strip().split(' ')
                        funcParams.append( {TYPE_MARKER: funcParameter[TYPE_ID], NAME_MARKER: funcParameter[NAME_ID]} )

                    funcDesc[PARAMETERS_MARKER] = funcParams
                    currentTable[METHOD_MARKER].append(funcDesc)

            if re.search("}", line) is not None:
                tableList.append(currentTable)
                currentTable = {}
                tableStarted = False
                enumeration  = False

    generateHeaderFile(tableList, scriptArgs.header)
    generateSourceFile(tableList, scriptArgs.header, scriptArgs.source)


if __name__=="__main__":
    main()

